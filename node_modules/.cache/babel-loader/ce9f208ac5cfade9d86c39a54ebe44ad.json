{"ast":null,"code":"import _regeneratorRuntime from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/cesarhugo.barzano/Desktop/CesarCorp/coins/fork/serum-dex-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nvar configurationValue = 1;\nvar endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nvar TransportWebUSB = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportWebUSB, _Transport);\n\n  var _super = _createSuper(TransportWebUSB);\n\n  function TransportWebUSB(device, interfaceNumber) {\n    var _this;\n\n    _classCallCheck(this, TransportWebUSB);\n\n    _this = _super.call(this);\n    _this.device = void 0;\n    _this.deviceModel = void 0;\n    _this.channel = Math.floor(Math.random() * 0xffff);\n    _this.packetSize = 64;\n    _this.interfaceNumber = void 0;\n    _this._disconnectEmitted = false;\n\n    _this._emitDisconnect = function (e) {\n      if (_this._disconnectEmitted) return;\n      _this._disconnectEmitted = true;\n\n      _this.emit(\"disconnect\", e);\n    };\n\n    _this.exchange = function (apdu) {\n      return _this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _assertThisInitialize, channel, packetSize, framing, blocks, i, result, acc, r, buffer;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _assertThisInitialize = _assertThisInitialized(_this), channel = _assertThisInitialize.channel, packetSize = _assertThisInitialize.packetSize;\n                log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                framing = hidFraming(channel, packetSize); // Write...\n\n                blocks = framing.makeBlocks(apdu);\n                i = 0;\n\n              case 5:\n                if (!(i < blocks.length)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 8;\n                return _this.device.transferOut(endpointNumber, blocks[i]);\n\n              case 8:\n                i++;\n                _context.next = 5;\n                break;\n\n              case 11:\n                if (result = framing.getReducedResult(acc)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                _context.next = 14;\n                return _this.device.transferIn(endpointNumber, packetSize);\n\n              case 14:\n                r = _context.sent;\n                buffer = Buffer.from(r.data.buffer);\n                acc = framing.reduceResponse(acc, buffer);\n                _context.next = 11;\n                break;\n\n              case 19:\n                log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                return _context.abrupt(\"return\", result);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        if (e && e.message && e.message.includes(\"disconnected\")) {\n          _this._emitDisconnect(e);\n\n          throw new DisconnectedDeviceDuringOperation(e.message);\n        }\n\n        throw e;\n      });\n    };\n\n    _this.device = device;\n    _this.interfaceNumber = interfaceNumber;\n    _this.deviceModel = identifyUSBProductId(device.productId);\n    return _this;\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  _createClass(TransportWebUSB, [{\n    key: \"close\",\n    value:\n    /**\n     * Release the transport device\n     */\n    function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.exchangeBusyPromise;\n\n              case 2:\n                _context2.next = 4;\n                return this.device.releaseInterface(this.interfaceNumber);\n\n              case 4:\n                _context2.next = 6;\n                return gracefullyResetDevice(this.device);\n\n              case 6:\n                _context2.next = 8;\n                return this.device.close();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey() {}\n  }], [{\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var device;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return requestLedgerDevice();\n\n              case 2:\n                device = _context3.sent;\n                return _context3.abrupt(\"return\", TransportWebUSB.open(device));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function request() {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n\n  }, {\n    key: \"openConnected\",\n    value: function () {\n      var _openConnected = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var devices;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return getLedgerDevices();\n\n              case 2:\n                devices = _context4.sent;\n\n                if (!(devices.length === 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", null);\n\n              case 5:\n                return _context4.abrupt(\"return\", TransportWebUSB.open(devices[0]));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function openConnected() {\n        return _openConnected.apply(this, arguments);\n      }\n\n      return openConnected;\n    }()\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(device) {\n        var iface, interfaceNumber, transport, onDisconnect;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return device.open();\n\n              case 2:\n                if (!(device.configuration === null)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                _context5.next = 5;\n                return device.selectConfiguration(configurationValue);\n\n              case 5:\n                _context5.next = 7;\n                return gracefullyResetDevice(device);\n\n              case 7:\n                iface = device.configurations[0].interfaces.find(function (_ref2) {\n                  var alternates = _ref2.alternates;\n                  return alternates.some(function (a) {\n                    return a.interfaceClass === 255;\n                  });\n                });\n\n                if (iface) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n\n              case 10:\n                interfaceNumber = iface.interfaceNumber;\n                _context5.prev = 11;\n                _context5.next = 14;\n                return device.claimInterface(interfaceNumber);\n\n              case 14:\n                _context5.next = 21;\n                break;\n\n              case 16:\n                _context5.prev = 16;\n                _context5.t0 = _context5[\"catch\"](11);\n                _context5.next = 20;\n                return device.close();\n\n              case 20:\n                throw new TransportInterfaceNotAvailable(_context5.t0.message);\n\n              case 21:\n                transport = new TransportWebUSB(device, interfaceNumber);\n\n                onDisconnect = function onDisconnect(e) {\n                  if (device === e.device) {\n                    // $FlowFixMe\n                    navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n                    transport._emitDisconnect(new DisconnectedDevice());\n                  }\n                }; // $FlowFixMe\n\n\n                navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n                return _context5.abrupt(\"return\", transport);\n\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[11, 16]]);\n      }));\n\n      function open(_x) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  return TransportWebUSB;\n}(Transport);\n\nexport { TransportWebUSB as default };\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = function (observer) {\n  var unsubscribed = false;\n  getFirstLedgerDevice().then(function (device) {\n    if (!unsubscribed) {\n      var deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel: deviceModel\n      });\n      observer.complete();\n    }\n  }, function (error) {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe: unsubscribe\n  };\n};\n\nfunction gracefullyResetDevice(_x2) {\n  return _gracefullyResetDevice.apply(this, arguments);\n}\n\nfunction _gracefullyResetDevice() {\n  _gracefullyResetDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(device) {\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            _context6.next = 3;\n            return device.reset();\n\n          case 3:\n            _context6.next = 8;\n            break;\n\n          case 5:\n            _context6.prev = 5;\n            _context6.t0 = _context6[\"catch\"](0);\n            console.warn(_context6.t0);\n\n          case 8:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 5]]);\n  }));\n  return _gracefullyResetDevice.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","endpointNumber","TransportWebUSB","device","deviceModel","channel","Math","packetSize","interfaceNumber","constructor","identifyUSBProductId","isSupported","list","getLedgerDevices","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","window","unsubscribe","requestLedgerDevice","devices","gracefullyResetDevice","iface","alternates","a","e","transport","onDisconnect","navigator","apdu","log","framing","hidFraming","blocks","i","result","r","buffer","Buffer","acc","setScrambleKey","console"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}